"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateRequestContext = CreateRequestContext;
exports.EnsureRequestContext = EnsureRequestContext;
const MikroORM_1 = require("../MikroORM");
const RequestContext_1 = require("../utils/RequestContext");
const EntityManager_1 = require("../EntityManager");
const EntityRepository_1 = require("../entity/EntityRepository");
const TransactionContext_1 = require("../utils/TransactionContext");
function CreateRequestContext(getContext, respectExistingContext = false) {
    return function (target, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = async function (...args) {
            // reuse existing context if available
            if (respectExistingContext && RequestContext_1.RequestContext.currentRequestContext()) {
                return originalMethod.apply(this, args);
            }
            // If we are inside explicit transaction context, we need to create another tx context.
            // Otherwise, the outer tx context would be preferred.
            const txContext = TransactionContext_1.TransactionContext.currentTransactionContext();
            const provider = txContext ? TransactionContext_1.TransactionContext : RequestContext_1.RequestContext;
            /* istanbul ignore next */
            let orm;
            let em;
            if (typeof getContext === 'function') {
                const context = await getContext(this);
                orm = context ?? await this.orm;
                em = context ?? await this.em;
            }
            else if (getContext) {
                orm = em = await getContext;
            }
            else {
                orm = await this.orm;
                em = await this.em;
            }
            const create = async (em) => {
                if (txContext) {
                    em = em.fork({ useContext: true });
                }
                return await provider.create(em, () => {
                    return originalMethod.apply(this, args);
                });
            };
            if (em instanceof EntityManager_1.EntityManager) {
                return await create(em);
            }
            if (orm instanceof EntityRepository_1.EntityRepository) {
                return await create(orm.getEntityManager());
            }
            if (!(orm instanceof MikroORM_1.MikroORM)) {
                const name = respectExistingContext ? 'EnsureRequestContext' : 'CreateRequestContext';
                throw new Error(`@${name}() decorator can only be applied to methods of classes with \`orm: MikroORM\` property, \`em: EntityManager\` property, or with a callback parameter like \`@${name}(() => orm)\` that returns one of those types. The parameter will contain a reference to current \`this\`. Returning an EntityRepository from it is also supported.`);
            }
            return await create(orm.em);
        };
        return descriptor;
    };
}
function EnsureRequestContext(getContext) {
    return CreateRequestContext(getContext, true);
}
