import type { EntityManager } from '../EntityManager';
import type { EntityData, EntityDTO, EntityProperty, FromEntityType, IsSubset, MergeSelected } from '../typings';
export declare class EntityAssigner {
    static assign<Entity extends object, Naked extends FromEntityType<Entity> = FromEntityType<Entity>, Convert extends boolean = false, Data extends EntityData<Naked, Convert> | Partial<EntityDTO<Naked>> = EntityData<Naked, Convert> | Partial<EntityDTO<Naked>>>(entity: Entity, data: Data & IsSubset<EntityData<Naked, Convert>, Data>, options?: AssignOptions<Convert>): MergeSelected<Entity, Naked, keyof Data & string>;
    private static assignProperty;
    /**
     * auto-wire 1:1 inverse side with owner as in no-sql drivers it can't be joined
     * also makes sure the link is bidirectional when creating new entities from nested structures
     * @internal
     */
    static autoWireOneToOne<T extends object, O extends object>(prop: EntityProperty<O, T>, entity: O): void;
    private static validateEM;
    private static assignReference;
    private static assignCollection;
    private static assignEmbeddable;
    private static createCollectionItem;
}
export declare const assign: typeof EntityAssigner.assign;
export interface AssignOptions<Convert extends boolean> {
    updateNestedEntities?: boolean;
    updateByPrimaryKey?: boolean;
    onlyProperties?: boolean;
    onlyOwnProperties?: boolean;
    convertCustomTypes?: Convert;
    mergeObjectProperties?: boolean;
    mergeEmbeddedProperties?: boolean;
    merge?: boolean;
    schema?: string;
    em?: EntityManager;
}
